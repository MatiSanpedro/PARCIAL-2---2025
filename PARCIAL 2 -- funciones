import pygame as pg 
import random 


#matrices 
def iniciar_matriz(cantidad_filas,cantidad_columnas,valor_inicial)->list:
    matriz = []
    for i in range(cantidad_filas):
        fila = [valor_inicial] * cantidad_columnas

        matriz += [fila]

    return matriz 



#escenario 

def dibujar_escenario_simple(pantalla, tamaño:int,columna:int,fila:int):

    for filass in range(fila):
        for columnass in range(columna): 
            rectangulo_agua = pg.Rect(columnass * tamaño, filass * tamaño, tamaño, tamaño)
            pg.draw.rect(pantalla, (0,0,200), rectangulo_agua) #cuadrados 
            pg.draw.rect(pantalla, (0,0,0), rectangulo_agua, 1) #lineas, bordes
            



#dibujar los barcos (requiere la matriz)
#esto ademas de dibujarlos en pantalla, devuelve los rectangulos que dibuje en una lista 


def dibujar_barcos(pantalla,matriz:list,tamaño):

   

    for filass in range(len(matriz)):
        for columnass in range(len(matriz[0])):
            
            if matriz[filass][columnass] == 1:
                rectangulo = pg.Rect(columnass * tamaño, filass * tamaño, tamaño, tamaño)
                pg.draw.rect(pantalla,(0,0,200),rectangulo)
                pg.draw.rect(pantalla, (0, 0, 0), rectangulo, 1)
                
                
                    
    
    

            

#Teclado:
def funcion_teclado(evento):
        if evento.type == pg.KEYDOWN:
            if evento.key == pg.K_ESCAPE:
                pass
                
            elif evento.key == pg.K_p:
                pg.mixer.music.pause()
            elif evento.key == pg.K_m:
                pg.mixer.music.stop()
            

        if evento.type == pg.KEYUP:
            print(" ")
        
#Mouse:
def funcion_mouse(evento):
    if evento.type == pg.MOUSEBUTTONDOWN:
        posicion = (evento.pos)
        print(f"click en{posicion}")
        if evento.button == 1:
            print("click izquierdo presionado")
        if evento.button == 3:
            print("click derecho presionado")
    
    

    


def mouse_de_inicio(boton1,boton2,boton3,boton4,evento,posicion):
    if evento.type == pg.MOUSEBUTTONDOWN:
        if evento.button ==1:
            print("  ")

        if boton1.collidepoint(posicion):                
            pantalla_actual = "nivel"

        elif boton2.collidepoint(posicion):
            pantalla_actual = "jugar"
            
        elif boton3.collidepoint(posicion):
            pantalla_actual = "ver puntaje"

        elif boton4.collidepoint(posicion):
            pg.quit()
            quit()


        return pantalla_actual




#funcion volver atras
def pausar_juego(evento,pantalla_actual):
    if evento.type == pg.KEYDOWN:
        if evento.key == pg.K_ESCAPE:
            pantalla_actual = "inicio"
            print("Juego Pausado.")
    
    return pantalla_actual



#pausa - despausa
def pausar_despausar(evento):
    if evento.type == pg.KEYDOWN:
        if evento.key == pg.K_p: # P = pausa 
            pg.mixer.music.pause()
            print("sonido pausado")
        if evento.key == pg.K_o: #O = despausa
            pg.mixer.music.unpause()
            print("Sonido reanudado")



#REINICIAR | requiere que le pase "evento" y "bandera_barcos"
def reiniciar_partida(evento,booleano,pantalla_actual,disparos_realizados,disparos_acertados,puntaje): 
    if evento.type == pg.KEYDOWN and evento.key ==pg.K_r:
        booleano = False
        disparos_realizados.clear() #vacio la lista de disparos para reiniciar la funcion
        disparos_acertados.clear()
        puntaje[0] -= puntaje[0]
        

    return booleano


'DIBUJOS EN PANTALLA'


#esto usa de parametros:
#1 Pantalla principal 
#2 tamaño de los cuadrados 
#3 cantidad de columnas
#4 cantidad de filas
#5  X desde donde comienza a dibujarse
#6 Y desde donde comienza a dibujarse

#dibuja los cuadraditos: 
def dibujar_cuadrados(pantalla, tamaño:int, columna:int, fila:int, x_inicial:int, y_inicial:int):     
    lista_retorno_de_cuadrados = []

    for filass in range(fila):
        for columnass in range(columna):
            rectangulo_azul = pg.Rect(x_inicial + columnass * tamaño, y_inicial + filass * tamaño,tamaño,
                tamaño 
                )
            pg.draw.rect(pantalla, (255, 234, 227), rectangulo_azul)      # cuadrados azules
            pg.draw.rect(pantalla, (0, 0, 0), rectangulo_azul, 1)     # bordes negros

            lista_retorno_de_cuadrados.append(rectangulo_azul)
            #retorna los cuadrados para usarlos despues en .collidepoint


    return lista_retorno_de_cuadrados




#lineas separadoras:
def dibujar_lineas(pantalla):
    #verticales             #color     #inicio     #fin
    pg.draw.line(pantalla, (0, 0, 0), (450, 150), (450,600), 6)
    pg.draw.line(pantalla, (0, 0, 0), (300, 150), (300,600), 6)
    
    #horizontales
    pg.draw.line(pantalla, (0, 0, 0), (150,300), (600,300), 6)
    pg.draw.line(pantalla, (0, 0, 0), (150,450), (600,450), 6)




#dibujar todo
def dibujar_todos_los_cuadrados(pantalla):
    
    celdas_sector_1 = dibujar_cuadrados(pantalla,50,3,3,150,150) #sector 1
    celdas_sector_2 = dibujar_cuadrados(pantalla,50,3,3,300,150) #sector 2
    celdas_sector_3 = dibujar_cuadrados(pantalla,50,3,3,450,150) #sector 3
    celdas_sector_4 = dibujar_cuadrados(pantalla,50,3,3,150,300) #sector 4
    celdas_sector_5 = dibujar_cuadrados(pantalla,50,3,3,300,300) #sector 5
    celdas_sector_6 = dibujar_cuadrados(pantalla,50,3,3,450,300) #sector 6
    celdas_sector_7 = dibujar_cuadrados(pantalla,50,3,3,150,450) #sector 7 
    celdas_sector_8 = dibujar_cuadrados(pantalla,50,3,3,300,450) #sector 8
    celdas_sector_9 = dibujar_cuadrados(pantalla,50,3,3,450,450) #sector 9 


#detecta las colisiones dentro de los cuadrados 
#recibe el evento del mouse, la posicion y una tupla para iterar con enumerate

def detectar_colisiones_simple(posicion,cuadrados):
    # Detectar clic en cuadrado
    for i, rect in enumerate(cuadrados):
        if rect.collidepoint(posicion):
            print(f"Hiciste clic en la celda número {i} en posición {rect.topleft}")
            

def detectar_colisiones_ingresar_texto(evento,pos, cuadrados, pantalla, fuente):
    cuadrado_seleccionado = None
    numero_ingresado = ""

    # Detectar clic en cuadrado
    for i, rect in enumerate(cuadrados):
        if rect.collidepoint(pos):
            print(f"Hiciste clic en la celda número {i} en posición {rect.topleft}")
            cuadrado_seleccionado = i
            break

    # Si se presiona una tecla y hay una celda seleccionada
    if evento.type == pg.KEYDOWN and cuadrado_seleccionado is not None:
        if evento.key == pg.K_BACKSPACE:
            numero_ingresado = ""
        elif evento.unicode.isdigit():
            numero_ingresado = evento.unicode
            if numero_ingresado < "1" or numero_ingresado > "9":
                numero_ingresado = ""

        # Dibujar el número en pantalla
        if numero_ingresado:
            rect = cuadrados[cuadrado_seleccionado]
            x, y = rect.center
            texto = fuente.render(numero_ingresado, True, (0, 0, 0))
            texto_rect = texto.get_rect(center=(x, y))
            pantalla.blit(texto, texto_rect)



def dibujar_numeros(pantalla, matriz: list, tamaño, fuente, posicion_x, posicion_y):
    lista_de_numeros = []

    for fila in range(len(matriz)):
        for columna in range(len(matriz[0])):

            valor = matriz[fila][columna]
            if valor != 0:  # Solo dibujo si no es cero

                # Calcular posición de la celda actual
                x = posicion_x + columna * tamaño
                y = posicion_y + fila * tamaño

                # Dibujar borde de celda (opcional)
                rect = pg.Rect(x, y, tamaño, tamaño)
                #pg.draw.rect(pantalla, (0, 0, 0), rect, 1)

                # Renderizar el número
                texto = fuente.render(str(valor), True, (158, 108, 100))
                
                # Centrar el número dentro de la celda
                texto_rect = texto.get_rect(center=(x + tamaño // 2, y + tamaño // 2))
                pantalla.blit(texto, texto_rect)

                lista_de_numeros.append(rect)

    return lista_de_numeros




#          parametros:     matriz | #cantidad de numeros para agregar
def agregar_numeros_al_azar(matriz, cantidad):
    #agrega numeros al azar, en lugares al azar en una matriz

    filas = len(matriz)
    columnas = len(matriz[0])
    contador = 0 #contador del bucle
    usados = set() #set de numeros ya usados

    while contador < cantidad: #definida por parametro 
        fila_al_azar = random.randrange(filas)  # fila al azar 
        columna_al_azar = random.randrange(columnas) #columna al azar 
        numero_al_azar = random.randint(1, 9) #numero al azar dentro de 1 y 9

        # si el lugar ya tiene un número distinto de 0, saltar
        if matriz[fila_al_azar][columna_al_azar] != 0:#esto es para no perder numeros en el contador y que al final agregue algo distinto de la cantidad que quiero
            continue
        #si el numero esta dentro de la lista de usados lo salto 
        if numero_al_azar in usados:
            continue

        # verifico que el numero no este en las filas
        if numero_al_azar in matriz[fila_al_azar]:
            continue

        # verifico que el numero no esté en la posicion "j", [0,1,2]
        repetido = False
        for j in range(filas): 
            if matriz[j][columna_al_azar] == numero_al_azar: # mira uno por uno dentro de la lista pequeña [0,1,2]
                repetido = True #si esta, freno
                break
        if repetido:
            continue #salto ese numero 

        # Si pasa todo esto, lo incluyo 
        matriz[fila_al_azar][columna_al_azar] = numero_al_azar
        contador += 1 #sumo 1 al contador y continua el bucle 
        usados.add(numero_al_azar)
    return matriz






def unir_matriz_general(matriz_general):
    """Une las 9 matrices 3x3 en una sola 9x9."""
    matriz_9x9 = []
    for fila_bloque in range(3):  # Cada bloque de 3 filas
        for fila_interna in range(3):
            fila_completa = []
            for col_bloque in range(3):
                fila_completa += matriz_general[fila_bloque * 3 + col_bloque][fila_interna]
            matriz_9x9.append(fila_completa)
    return matriz_9x9




def agregar_numeros_al_azar_9x9(matriz, cantidad):
    """
  no sirve 
    """
    filas = len(matriz)
    columnas = len(matriz[0])

    # 1) Conjunto de números ya presentes en la matriz (no tocar)
    existentes = set()
    posiciones_vacias = []
    for r in range(filas):
        for c in range(columnas):
            val = matriz[r][c]
            if val == 0:
                posiciones_vacias.append((r, c))
            else:
                existentes.add(val)

    # Números posibles (1..9)
    todos_numeros = set(range(1, 10))
    disponibles_global = todos_numeros - existentes

    # Si no hay números disponibles o no hay posiciones vacías, salimos
    if not disponibles_global or not posiciones_vacias:
        return matriz

    # Ajustar 'cantidad' al máximo disponible
    max_posibles = min(len(posiciones_vacias), len(disponibles_global))
    if cantidad > max_posibles:
        cantidad = max_posibles  # autocorrección silenciosa

    contador = 0

    # Trabajamos sobre una copia de la lista de posiciones vacías para eliminar las que no sirven
    posiciones = posiciones_vacias[:]

    while contador < cantidad and posiciones:
        # 2) Elegir una posición vacía al azar (más eficiente que elegir filas/cols al azar)
        fila, columna = random.choice(posiciones)

        # 3) Calcular los números que ya están en la fila y en la columna
        numeros_en_fila = set(matriz[fila])
        numeros_en_columna = set(matriz[r][columna] for r in range(filas))

        # 4) Conjunto de números válidos para esta posición:
        permitidos = disponibles_global - numeros_en_fila - numeros_en_columna

        if not permitidos:
            # Esta posición no admite ningún número válido; la descartamos
            posiciones.remove((fila, columna))
            continue

        # 5) Elegir un número al azar entre los permitidos
        numero = random.choice(list(permitidos))

        # 6) Insertar y actualizar estructuras
        matriz[fila][columna] = numero
        existentes.add(numero)
        disponibles_global.remove(numero)
        posiciones.remove((fila, columna))
        contador += 1

    return matriz




#probar esto es para volver a hacer submatrices de 3x3 a partir de la general
def agregar_por_sector(matriz_general, cantidad_por_sector):
    # Recorremos la matriz general en bloques de 3x3
    for bloque_fila in range(0, 9, 3):        # 0, 3, 6
        for bloque_columna in range(0, 9, 3): # 0, 3, 6
            # Crear una submatriz temporal 3x3
            submatriz = [fila[bloque_columna:bloque_columna+3] for fila in matriz_general[bloque_fila:bloque_fila+3]]

            # Agregar números a esa submatriz
            submatriz = agregar_numeros_al_azar(submatriz, cantidad_por_sector)

            # Volver a colocar la submatriz modificada en la matriz general
            for i in range(3):
                for j in range(3):
                    matriz_general[bloque_fila + i][bloque_columna + j] = submatriz[i][j]
    return matriz_general






def agregar_numeros_por_sector(matriz):
    # Recorremos los 9 sectores 3x3
    for fila_sector in range(0, 9, 3):  # 0, 3, 6
        for columna_sector in range(0, 9, 3):  # 0, 3, 6
            
            usados = set()  # números usados en este sector
            contador = 0

            while contador < 5:  # 5 números por sector
                fila_rel = random.randint(0, 2)      # posición relativa dentro del sector
                col_rel = random.randint(0, 2)
                fila_abs = fila_sector + fila_rel     # posición absoluta dentro de la matriz
                col_abs = columna_sector + col_rel

                if matriz[fila_abs][col_abs] != 0:
                    continue

                numero = random.randint(1, 9)
                if numero in usados:
                    continue

                matriz[fila_abs][col_abs] = numero
                usados.add(numero)
                contador += 1

    return matriz





def mover_numeros_en_conflicto(matriz):
    filas = len(matriz)
    columnas = len(matriz[0])
    
    # Función auxiliar para mover un número específico
    def mover_numero(matriz, fila_actual, col_actual, numero):
        lugares_validos = []
        for f in range(filas):
            for c in range(columnas):
                if matriz[f][c] == 0:
                    # Verifica que el número no esté en la fila ni en la columna
                    if numero not in matriz[f]:
                        columna_actual = [matriz[i][c] for i in range(filas)]
                        if numero not in columna_actual:
                            lugares_validos.append((f, c))
        
        if lugares_validos:
            nueva_fila, nueva_col = random.choice(lugares_validos)
            matriz[fila_actual][col_actual] = 0
            matriz[nueva_fila][nueva_col] = numero
    
    # Revisar cada fila y cada columna
    for f in range(filas):
        for c in range(columnas):
            numero = matriz[f][c]
            if numero == 0:
                continue
            
            # Verificar conflicto en fila
            if matriz[f].count(numero) > 1:
                mover_numero(matriz, f, c, numero)
                continue  # ya lo movió, sigue
            
            # Verificar conflicto en columna
            columna = [matriz[i][c] for i in range(filas)]
            if columna.count(numero) > 1:
                mover_numero(matriz, f, c, numero)
    
    return matriz



def agregar_numeros_al_azar_de_verdad(matriz, cantidad=5):
    # agrega numeros al azar, en lugares al azar en una matriz 9x9

    filas = len(matriz)
    columnas = len(matriz[0])
    contador = 0  # contador del bucle
    usados = set()  # set de numeros ya usados

    while contador < cantidad:  # definida por parametro
        fila_al_azar = random.randrange(filas)        # fila al azar (0 a 8)
        columna_al_azar = random.randrange(columnas)  # columna al azar (0 a 8)
        numero_al_azar = random.randint(1, 9)         # numero al azar entre 1 y 9

        # si el lugar ya tiene un número distinto de 0, saltar
        if matriz[fila_al_azar][columna_al_azar] != 0:
            continue

        # si el numero está dentro de la lista de usados, lo salto
        if numero_al_azar in usados:
            continue

        # verifico que el numero no esté en la fila
        if numero_al_azar in matriz[fila_al_azar]:
            continue

        # verifico que el numero no esté en la columna
        repetido = False
        for j in range(filas):
            if matriz[j][columna_al_azar] == numero_al_azar:
                repetido = True
                break
        if repetido:
            continue

        # si pasa todo esto, lo incluyo
        matriz[fila_al_azar][columna_al_azar] = numero_al_azar
        contador += 1
        usados.add(numero_al_azar)

    return matriz



def agregar_la_concha_de_tu_madre(matriz,cantidad):
    # agrega numeros al azar, en lugares al azar en una matriz 9x9
    filas = len(matriz)
    columnas = len(matriz[0])
    contador = 0  # contador del bucle
    usados = set()  # set de numeros ya usados
    

    while contador < cantidad:  # definida por parametro
        fila_al_azar = random.randrange(filas)        # fila al azar (0 a 8)
        columna_al_azar = random.randrange(columnas)  # columna al azar (0 a 8)
        numero_al_azar = random.randint(1, 9)         # numero al azar entre 1 y 9
