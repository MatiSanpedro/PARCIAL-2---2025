
#RELOJ.PY
from datetime import datetime
import time 
import winsound

winsound.PlaySound("C:\Users\Kaio\Downloads\el_vino_me_pego.mp3", winsound.SND_FILENAME)

import time
from datetime import datetime
import winsound

hora_alarma = input("Ingresa la hora de la alarma (HH:MM): ")

print(f"Alarma programada para las {hora_alarma}...")

while True:
    hora_actual = datetime.now().strftime("%H:%M")
    if hora_actual == hora_alarma:
        print("‚è∞ ¬°Despierta!")
        winsound.PlaySound("C:\Users\Kaio\Downloads\el_vino_me_pego.mp3", winsound.SND_FILENAME)
        break
    time.sleep(1)


###################################################################



#pruebas.py
import random


def agregar_numeros_9_matrices(matrices, cantidad):

    # matrices es una lista de 9 matrices de 3x3
    # ejemplo: matrices = [matriz1, matriz2, ..., matriz9]

    usados = set()        # n√∫meros ya puestos en cualquier matriz
    contador = 0

    while contador < cantidad:

        # elegir matriz al azar (0 a 8)
        idx = random.randrange(9)
        matriz = matrices[idx]

        # elegir fila y columna al azar
        fila = random.randrange(3)
        col = random.randrange(3)

        # numero aleatorio
        numero = random.randint(1, 9)

        # EVITAR colocar sobre un n√∫mero existente
        if matriz[fila][col] != 0:
            continue

        # EVITAR n√∫meros repetidos globalmente (en las 9 matrices)
        if numero in usados:
            continue

        # EVITAR repetici√≥n en la FILA dentro de esa matriz
        if numero == matriz[fila][0] or numero == matriz[fila][1] or numero == matriz[fila][2]:
            continue

        # EVITAR repetici√≥n en la COLUMNA dentro de esa matriz
        repetido = False
        j = 0
        while j < 3:
            if matriz[j][col] == numero:
                repetido = True
                j = 3
            else:
                j += 1
        if repetido:
            continue

        # SI PAS√ì TODO, COLOCAMOS EL N√öMERO
        matriz[fila][col] = numero
        usados.add(numero)
        contador += 1

    return matrices



matriz_sector_1 = [[0,0,0],[0,0,0],[0,0,0]]
matriz_sector_2 = [[0,0,0],[0,0,0],[0,0,0]]
matriz_sector_3 = [[0,0,0],[0,0,0],[0,0,0]]
matriz_sector_4 = [[0,0,0],[0,0,0],[0,0,0]]
matriz_sector_5 = [[0,0,0],[0,0,0],[0,0,0]]
matriz_sector_6 = [[0,0,0],[0,0,0],[0,0,0]]
matriz_sector_7 = [[0,0,0],[0,0,0],[0,0,0]]
matriz_sector_8 = [[0,0,0],[0,0,0],[0,0,0]]
matriz_sector_9 = [[0,0,0],[0,0,0],[0,0,0]]


matrices = [matriz_sector_1,matriz_sector_2,matriz_sector_3,matriz_sector_4,matriz_sector_5,
            matriz_sector_6,matriz_sector_7,matriz_sector_8,matriz_sector_9]

matrices_numeros = agregar_numeros_9_matrices(matrices,9)
matrices_numeros = agregar_numeros_9_matrices(matrices,9)
matrices_numeros = agregar_numeros_9_matrices(matrices,9)
matrices_numeros = agregar_numeros_9_matrices(matrices,9)
matrices_numeros = agregar_numeros_9_matrices(matrices,9)

  

def hallar_repetidos_verticales(matriz1, matriz4, matriz7):
    repetidos = []  # lista donde guardaremos los n√∫meros repetidos

    # Recorremos columna por columna
    for col in range(3):  # cada matriz es 3x3
        numeros_vistos = set()

        # Recorremos las tres matrices en la misma columna
        for matriz in (matriz1, matriz4, matriz7):
            for fila in range(3):
                numero = matriz[fila][col]

                # ignoramos los ceros (casillas vac√≠as)
                if numero == 0:
                    continue

                # si ya vimos ese n√∫mero en la misma columna, est√° repetido
                if numero in numeros_vistos:
                    repetidos.append((numero,fila, col))                       

                else:
                    numeros_vistos.add(numero)
    
    # Mostramos los resultados
    if repetidos != 0:
        print("Repetidos encontrados (n√∫mero, columna):", repetidos)
    else:
        print("No hay n√∫meros repetidos en columnas.")

    return repetidos




#probar esto, todavia no lo use, mirar si realmente borra los repetidos 
def quitar_repetidos_verticales(matriz1, matriz4, matriz7):
    matrices = [matriz1, matriz4, matriz7]

    # Recorre columna por columna
    for col in range(3):
        numeros_vistos = {}   # n√∫mero ‚Üí (indice_matriz, fila)

        # Recorremos las 3 matrices
        for idx_matriz, matriz in enumerate(matrices):
            for fila in range(3):
                numero = matriz[fila][col]

                if numero == 0:
                    continue

                if numero not in numeros_vistos:
                    # Guardamos el primer lugar donde apareci√≥
                    numeros_vistos[numero] = (idx_matriz, fila)
                else:
                    # BORRAMOS la repetici√≥n
                    print(f"Borrando n√∫mero repetido: {numero} en matriz {idx_matriz}, fila {fila}, columna {col}")
                    matriz[fila][col] = 0  # lo borramos

    return matriz1, matriz4, matriz7





def agregar_numeros_9_matrices(matrices, cantidad):
    #esta funcion NO FUNCIONA con una cantidad mayor a 9
    #debe ser llamada varias veces o se traba 

    usados = set()        # n√∫meros ya puestos en cualquier matriz
    contador = 0

    while contador < cantidad:

        # elegir matriz al azar (0 a 8)
        idx = random.randrange(9)
        matriz = matrices[idx]

        # elegir fila y columna al azar
        fila = random.randrange(3)
        col = random.randrange(3)

        # numero aleatorio
        numero = random.randint(1, 9)

        # EVITAR colocar sobre un n√∫mero existente
        if matriz[fila][col] != 0:
            continue

        # EVITAR n√∫meros repetidos globalmente (en las 9 matrices)
        if numero in usados:
            continue

        # EVITAR repetici√≥n en la FILA dentro de esa matriz
        if numero == matriz[fila][0] or numero == matriz[fila][1] or numero == matriz[fila][2]:
            continue

        # EVITAR repetici√≥n en la COLUMNA dentro de esa matriz
        repetido = False
        j = 0
        while j < 3:
            if matriz[j][col] == numero:
                repetido = True
                j = 3
            else:
                j += 1
        if repetido:
            continue

        # SI PAS√ì todo, COLOCAMOS EL N√öMERO
        matriz[fila][col] = numero
        usados.add(numero)
        contador += 1

    return matrices


'poner esto al inicio del case "jugar" para obtener la posicion del mouse sin dramas '
#pos = pg.mouse.get_pos()


def detectar_colisiones_ingresar_texto(evento, pos, cuadrados, matriz_general, pantalla, fuente):
    celda = None

    # --- 1. detectar clic en alguna celda ---
    if evento.type == pg.MOUSEBUTTONDOWN:
        for i, rect in enumerate(cuadrados):
            if rect.collidepoint(pos):
                celda = i
                break
        return None   # esperar que el usuario escriba el n√∫mero

    # --- 2. si se presiona una tecla y hay celda seleccionada ---
    if evento.type == pg.KEYDOWN and detectar_colisiones_ingresar_texto.celda_activa is not None:
        indice = detectar_colisiones_ingresar_texto.celda_activa
        fila = indice // 9
        col = indice % 9

        # borrar n√∫mero (BACKSPACE)
        if evento.key == pg.K_BACKSPACE:
            matriz_general[fila][col] = 0
            return

        # registrar n√∫mero
        if evento.unicode.isdigit():
            num = int(evento.unicode)
            if 1 <= num <= 9:
                matriz_general[fila][col] = num

    # guardar celda seleccionada para teclado
    detectar_colisiones_ingresar_texto.celda_activa = celda


‚ö† Necesario agregar esta l√≠nea una sola vez:
detectar_colisiones_ingresar_texto.celda_activa = None


Ponela despu√©s de definir la funci√≥n, as√≠:

def detectar_colisiones_ingresar_texto(...):
    ...
    ...

detectar_colisiones_ingresar_texto.celda_activa = None

üß† ¬øQu√© hace exactamente esta funci√≥n?
1) Cuando hac√©s clic:

Detecta qu√© celda de las 81 tocaste.

Guarda ese √≠ndice interno (celda_activa).

No dibuja nada todav√≠a.

2) Cuando escrib√≠s un n√∫mero (KEYDOWN):

Convierte el √≠ndice en fila/columna dentro de la matriz de 9√ó9.

Guarda el n√∫mero directamente dentro de:

matriz_general[fila][col]


As√≠ el n√∫mero:
‚úî queda guardado
‚úî no desaparece en el siguiente frame
‚úî aparece autom√°ticamente cuando llam√°s a dibujar_numeros

üìå C√≥mo la us√°s en tu bucle
pos = pg.mouse.get_pos()

if evento.type in (pg.MOUSEBUTTONDOWN, pg.KEYDOWN):
    detectar_colisiones_ingresar_texto(
        evento,
        pos,
        todas_las_celdas,     # las 81 celdas unidas
        matriz_general,
        pantalla,
        fuente
    )

üìå IMPORTANTE

Deb√©s tener esto:

todas_las_celdas = (
    celdas_sector_1 + celdas_sector_2 + celdas_sector_3 +
    celdas_sector_4 + celdas_sector_5 + celdas_sector_6 +
    celdas_sector_7 + celdas_sector_8 + celdas_sector_9
)


y pasarlo como par√°metro.
